一、来源：
   之前在一个前端公众号看到一篇文章提到一个语雀的划词评论功能，当时觉得挺有意思，就想着自己实现一下，于是自己尝试着写一下，就有了这个小插件...
    
二、思路：
    实现本例中的划词评论功能，主要就是解决几个问题：

    1.划词：
        Why：用户按下鼠标选中文章中的某一个字，词，句
        How：
                一.使用 document.getSelection().getRangeAt(0) 获取当前用户选中的文本范围及相应信息：
                
                    1.startContainer ---> 选中内容起始节点
                    2.startOffset, ---> 选中内容起始节点偏移量(就是开始的这个字是选中内容起始节点中的第几个字)
                    3.endContainer, ---> 选中内容终止节点
                    4.endOffset ---> 选中内容终止节点偏移量(就是结束的这个字是选中内容终止节点中的第几个字)

                二.使用 document.createRange() 创建一个 Range对象 用来保存单次划词内容，位置，为这个Range对象创建一个随机数的ID
                三.将 Range 添加至 RangeList 中（为了后面目标区域尺寸变化后更新已创建 Range 的新位置）
                四.当鼠标抬起时，判定已经完成单次划词操作
                  1：需要监听用户的mousedown事件及mouseup事件：
                    (1) mousedown：
                        需要记录用户当前按下鼠标时的页面坐标
                    (2) mouseup：
                        需要记录用户当前抬起鼠标时的页面坐标，如果鼠标抬起时的坐标 == 鼠标上次记录的按下时的坐标时，判定是点击，则不需要创建 Range 以及后续操作...
                        反之需要创建 Range、Range 所对应的 rect、绘制 konva.line、绘制 konva.rect以及数据上显表格，详见 jqProEntry.js 的 line750

    2.评论：
        Why：用户想对刚划词的字，词，句进行评论
        How：
                一.当鼠标抬起时，在抬起位置创建一个自定义样式的按钮，为这个按钮绑定 click 事件
                二.当点击评论后，可以使用任意的交互行为让用户填写评论内容

    3.上显划词区域：
        Why：评论后怎么将用户刚划词的区域显示出来?
        How：一开始我想的是创建一个只有下边框的div，宽度为字的大小 * 字数，高为字的大小 * 行高，但是有个问题就是如果跨行就很麻烦
                后来想到可以在文章内容区域盖上一个透明的canvas画布，于是使用 konva.js 来实现:

                绘制canvas：

                一.先创建layer --- 图层
                二.再创建stage --- 舞台（画布）
                三.将创建好的layer添加至舞台（画布）   
                四.根据划词区域相应的位置信息绘制下划线（line）和可高亮的背景矩形（rect）（一开始需要隐藏），并添加 line的ID(为Range的ID)，rect的ID(为Range的ID)和rect的type ：

                    如果划词区域跨行，可使用 Range.getClientRects() 获取当前选中范围的所有矩形框。它返回一个包含所有矩形框的数组,每个矩形框表示选中范围在页面上的位置和大小。
                    意味着 如果框选区域是 x 行，那么返回的数组有 x 项;

                    但是在写的过程中发现会有一些额外情况：

                    如果划词区域有 br 换行标签，Range.getClientRects() 会算作一行，如果给这行添加划线，会产生没必要的多余内存消耗，所以要将其排除在外：
                    可以根据这行的 width 是否为 0 且 height 是否为 0 且 这行的 width 不可占满 判断是否满足条件
                    当用户选中占满单行的文字的时候，其实此行选中的文字最左边界离容器最左边是有一定距离的，
                    所以如果选中的文字宽度 + 左右内边距（如果存在） = 容器宽度，说明此行无可选中的文字

                    p.s：比如划词区域对应的内容源代码是这样：
                        start
                        <br/>
                        <p></p>
                        End

                    其中的p元素在不单独设置宽度的情况下因为是块盒会占满整行（width = 容器的width + 左右padding）但是里面没内容,也不用生成划线，所以也要将其排除在外,
                    如果这个 p 元素内容不为空，那么 Range.getClientRects() 返回的这一行的 height 不会为 0;
                    如果这个 p 元素内容为空，那么 Range.getClientRects() 返回的这一行的 height 为 0;

                    所以:
                        可以根据 width 是否为 0 判断这行是否是 <br/>;
                        可以根据 height 是否为 0 且 这行的 width + 外部容器的左右内边距（如果存在） = 容器宽度 判断是否是空内容的有默认margin的块盒元素（p,h1 ~ h5）;
                
    4.获取当前文章的所有段落的文字并进行分段格式化数据（为了后面读取数据库内的数据，从而能找到之前已评论的语句）：
        Why：一段文章如果是分段落存在于多个节点中时，那么就会导致使用 document.getSelection().getRangeAt(0) 获取的划词开始偏移量和结束偏移量会和想象中的不一致，例如：
            <div>12345<span style = 'color:red'>67890</span>abcdef</div>
            上述文章中，如果划词区域是 4567890ab 的话，我们想得到的开始偏移量和结束偏移量应该是 3,12，但其实得到的是 3,2；因为 45、67890、ab 分别存在与三个标签中
            （浏览器会给无标签包裹的文本节点创建一个匿名行盒，也就是文章中的 12345 和 abcdef）
            原因是 12345 67890 abcdef 三段文字分别包含于三个元素中，所以划词的开始偏移量是 '4' 在匿名行盒 --- 12345 中的位置，而结束偏移量是 'b' 在匿名行盒 --- abcdef 中的位置

            所以需要对文章内容按照是否被子元素包裹进行分段处理
        
        How：
            一.递归查找指定文档里所有 Text 元素(及其所有后代元素):
               1.声明一个 List；
               2.将对应的文本节点的子元素组传入方法进行递归查找
               3.如果满足子元素为文本节点（xxx.nodeName == '#text'）且 内容不为空（xxx.textContent != ""）,将其按照格式：
                    {
                        _node：xxx, ---> 文本节点
                        _nodeLength:xxx.length ---> 文本节点内容长度
                    }
                 放入 List 中...
               4.格式化完后的数据是：
                 [
                      第一段落
                      {
                          _node:文本节点
                          _nodeLength:文本节点内容长度
                      },
                      第二段落
                      {
                          _node:文本节点
                          _nodeLength:文本节点内容长度
                      },
                      第三段落
                      {
                          _node:文本节点
                          _nodeLength:文本节点内容长度
                      },
                  ]
               5. 算出每一段在整篇文章中的开始位置 [_nodeStartPos]（偏移字数）和终止位置[_nodeEndPos]（偏移字数）
                  目的是为了每次保存的时候，传给后台的其实是一个数组，数组每项记录的是当前用户选中的每句话是从 整篇文章中的第几个字开始 至 整篇文章中的第几个字结束
       
                  遍历格式化完后的数据...
                  当前段落在整篇文章中的起始文字偏移(用人话说就是：这一段是从这篇文章的第几个字开始的) = 如果当前为第一段，开始位置为 0；否则：上一段的起始位置 + 上一段的总字数
                  当前段落在整篇文章中的终止文字偏移(用人话说就是：这一段是到这篇文章的第几个字结束的)  = 如果当前为第一段，终止位置为 当前段落的总字数；否则：当前段落的起始位置 + 当前段落的总字数
               
               具体代码见 jqProTools.js 中的 recursionListToFormat

    5.将 Range.getClientRects 得出来的所有行的 rect 组添加 _start_pos(从哪一段落的第几个字开始) 和 _end_pos(从哪一段落的第几个字结束)：
      Why：需要给每个Range在页面上所涉及的所有区域根据 Range 的 startContainer 和 endContainer 与上一步分好段的文章数据进行匹配，并添加这个rectList（页面上 Range 对应的所有行区域）的开始位置（_start_pos）和结束位置（_end_pos），为了当下次调接口拿数据
           的时候就可以知道用户上次划的是哪些词或句
      How：
            _start_pos: 当前Range的开始偏移量（startOffset）+ 当前Range第一个字所在段落的起始文字偏移（从这篇文章的第几个字开始的）
            _end_pos: 当前Range的结束偏移量（startOffset）+ 当前Range最后一个字所在段落的起始文字偏移（从这篇文章的第几个字开始的）

            比如：
                123456
                <br/>
                7890
                <br/>
                abcdef

            当前选中的区域（Range）是 4567890ab
            那么当前Range对应的rects: 
                _start_pos = 3 + 0;
                _end_pos = 2 + 11;
      
    6.将 Range.getClientRects 得出来的所有行的 rect 组（这个rect组的ID为 Range 的 Id）添加至全局的 allRectList 中；
      Why：方便以后通过 ID 查找到指定的 Range 对应的 rect组区域；
        并为每个rect组中的每一行rect区域添加可能需要的位置数据：
        （1）每一行矩形区域横坐标起始位置：可直接获得
        （2）每一行矩形区域横坐标终止位置：横坐标起始位置 + 当前rect的宽度
        （3）每一行矩形区域纵坐标起始位置：可直接获得
        （4）每一行矩形区域纵坐标终止位置：纵坐标起始位置 + 当前rect的高度
        （5）每一行矩形区域所占的宽度：可直接获得
        （6）每一行矩形区域所占的高度：可直接获得

      How：
        遍历 allRectList，为每个rect区域组内的每一个rect添加 x,y,width,height，并存入一个对象 _posFormat 中，为每一个rect添加 rType（其存在于的rect组的_rectType）

    7.监听目标区域变化
      Why：需要监听目标区域变化，页面的尺寸变化及各种其他情况导致的目标区域元素重绘或者重排，那已创建的所有Range在页面中存在的区域尺寸需要重新计算，
            并且Range所关联的所有 konva 中绘制的线和矩形区域需要根据新位置重新绘制
      
      How：
        一.使用 H5 的 ResizeObserver 对象监听元素的尺寸变化，当尺寸变化时，重新给 canvas 画布赋值宽，高，左边距，上边距的几何尺寸...
        二.目标区域尺寸变化后，需要更新所有用户选中区域 Range 的新位置：

            1.遍历当前页面里的所有 Range (RangeList)
            2.因为 之前的处理逻辑中，一个 Range 必然会在 allRectList 中有一个对应的 rectList（区域在页面中占据的每一行的位置信息）
            3.通过 Range 的 id 找到页面中对应的 Range，重新查找此 Range 在屏幕上所占的全部区域 rect 组，将原来rect组的 ID 和 Type 重新赋值给 新的rect 组
            4.遍历 allRectList,通过rangeID 找到对应的 rectList，将上一步的 rect组（rectList）替换原来的 rectList，并重新为每个rect组中的每一行rect区域添加可能需要的位置数据（横纵坐标范围，所占区域宽高）
            5.调用 jqProEntry.js 中的 updateLayer 方法更新当前layer中的所有图元（下划线Line、矩形Rect）

    8.监听目标区域的滚动事件
      Why：如果目标区域有滚动条时，在页面上下左右每一次滚动时，需要改变滚动前页面上的每行区域在整个页面的位置，
           当页面滚动后，用户点击已划词区域时，会出现因为位置改变导致划词区域无法高亮的 BUG

      How：
        一.获取当前滚动的垂直距离
        二.获取当前滚动的水平距离
        三.获取当前滚动时，当前水平单次位移量（当前滚动的水平距离 - 上次滚动的水平距离）
        四.获取当前滚动时，当前垂直单次位移量（当前滚动的垂直距离 - 上次滚动的垂直距离）
        五.记录当前滚动的水平位置（作为下次滚动时的上一次横向滚动位置）
        六.记录当前滚动的垂直位置（作为下次滚动时的上一次纵向滚动位置）
        七.如果水平单次位移量 + 垂直单次位移量之和大于 0，则说明用户这次不是垂直移动就是水平移动了
        八.遍历目前所有 Range 所占页面的所有所有矩形框 rect 组（allRectList），再更改其所有的 rect（区域在页面中占据的每一行的位置矩形）的 位置信息：
            1.横坐标起始位置 = 原横坐标起始位置 + 当前水平滚动的距离（正为向右，负为向左）
            2.横坐标结束位置 = 现横坐标起始位置 + 当前矩形宽度
            3.纵坐标起始位置 = 原纵坐标起始位置 + 当前垂直滚动的距离（正为向下，负为向上）
            4.纵坐标结束位置 = 现纵坐标起始位置 + 当前矩形高度

    9.如何保存当前划词区域的数据
      Why：需要拿到当前所有划词区域相关数据（划词内容，评论内容，划词内容起止坐标 --- 通俗的说就是当前划词内容是从文章中的第几个字到第几个字，当前内容区域的空白折叠）存入后台，方便下次回显在页面上
            格式为：
                [
                    {
                        hcnr:xxx, ---> 当前选中内容
                        plnr:xxx, ---> 对当前选中内容的评论内容
                        id:xxx, ---> 当前选中区域对象的ID（Range的ID）
                        sPos:xxx, ---> 划词内容起始偏移量
                        ePos:xxx, ---> 划词内容终止偏移量
                        blankFold:xxx ---> 当前文章的空白折叠
                    }
                ]
      How：
        一.这些数据最好是在点击评论按钮且输入完评论内容后存储（因为在这里是可以拿到用户的评论内容和划词 Range 的）
        二.可以通过 Range.toString() 拿到当前的划词内容
        三.储存当前文章中的空白折叠，应该在初始化插件里 init() 方法内计算出来，这里获取并保存：
           1.一段文章的源代码中开头可能会有空白折叠：因为源代码里内容和标签一般书写习惯不是紧挨在一起的，
             但是 Range 的 startOffset 是依照一个元素中的 innerHTML 的内容来计算偏移量的，所以会导致偏移量现实和想象中的不符
             故而储存的数据中的 sPos（起始文字偏移量）其实是等于：页面中字所在文章中的位置 + 文章开头的空白折叠字符数量
             比如：
                 源代码中：
                    <div>
                        测试代码一二三
                    </div>
            上述代码中 第一个字 “测” 的实际在文档中的位置其实应该是 1 + 文章开头的空白折叠字符数量
        
           2.如何算出空白折叠:使用当前文章中的第一个字（innerText）在 当前文章区域DOM的 innerHTML 中的下标
        四.在插件声明类的内部使用一个List来存储划词区域的相关数据（详情请见 jqProEntry.js class UnderlineComments 中的 rectPosList）

    10.如何将后台返回的数据回显到页面
       Why：当后台返回了之前保存的所有划词区域，应该将其显示在文章中
       How：
            后台返回数据格式：
                [
                    {
                        hcnr:xxx, ---> 之前选中内容
                        plnr:xxx, ---> 对之前选中内容的评论内容
                        id:xxx, ---> 之前选中区域对象的ID（Range的ID）
                        sPos:xxx, ---> 之前划词内容起始偏移量
                        ePos:xxx, ---> 之前划词内容终止偏移量
                        blankFold:xxx ---> 之前文章的空白折叠
                    }
                ]
            一.需要深拷贝数据源，防止后续操作改变源数据
            二.绘制画布并使用 ResizeObserver 构造函数创建 ResizeObserver 对象监听元素的尺寸变化
            三.将后台返回的值赋值给需保存传入后台的数据列表中，因为后台返回的值就是上次保存后的值
            四.将现文章进行段落分割（为了根据数据源中的 sPos 起始偏移量 --- 从文章中的第几个字开始, ePos 终止偏移量 --- 到文章中的第几个字结束 来找到当前对应的是文章中的什么内容）:
            五.一般来说，如果文章内容没有被修改的情况下，现在文章的空白折叠应该与之前文章的一致，
               但是如果文章内容被改，或者其他情况导致现在文章和之前文章的空白折叠不一样的话，要做异常处理：
               先获取当前文章的空白折叠，与之前文章的空白折叠比较计算
               遍历后台数据，根据空白折叠差算出每一条数据的现在起止偏移量:
               所以现在每条数据的 sPos -= (oldBlankFold - newBlankFold);
                                ePos -= (oldBlankFold - newBlankFold);

            六.遍历已分割的所有文章段落，算出每一段在整篇文章中的起止偏移量：_nodeStartPos，_nodeEndPos：
            （可以通过 jqProTools.js 中的 recursionListToFormat 这个方法得出）
               如果传入数据项的起始文字偏移量在某一段占据整篇文章的起止偏移量内，那么满足条件的那一段为开始段落
               如果传入数据项的终止文字偏移量在某一段占据整篇文章的起止偏移量内，那么满足条件的那一段为结束段落

               例如：
               当传入的数据为{ ...
                              sPos:100, --- 数据库中存储的划词区域在文章中的开始文字位置
                              ePos:196, --- 数据库中存储的划词区域在文章中的终止文字位置
                              ...
                            }
              
               假设文章有四段：
                   第一段是文章的 0 ~ 110 个字
                   第二段是文章的 111 ~ 190 个字
                   第三段是文章的 191 ~ 201 个字
                   第四段是文章的 202 ~ 365 个字
              
               就说明当前划词区域是从文章的第100个字所在的段落 到 文章的第196个字所在的段落，也就是划词区域从第一段开始到第三段结束

            六.创建一个Range，设置 Range 的起止位置和起止文本内容
               range.setStart(开始段落所对应的Node，当前数据在整篇文章的偏移量 - 开始段落在整篇文章的起始偏移量)
               range.setEnd(结束段落所对应的Node，当前数据在整篇文章的偏移量 - 结束段落在整篇文章的起始偏移量)
         
               因为后台存储的每条数据中的 sPos,ePos 是上一次划词区域在整篇文章中的起止偏移量

               所以新创建的 Range 的 setStart 中的偏移量应该要用每一条数据在全文中的偏移量 sPos - 这条数据所在的开始段落在全文的起始偏移量
               所以新创建的 Range 的 setEnd 中的偏移量应该要用每一条数据在全文中的偏移量 ePos - 这条数据所在的结束段落在全文的起始偏移量

               还是上面的例子：
                  range.setStart(开始段落所对应的Node,100 - 0);
                  range.setEnd(结束段落所对应的Node,196 - 191);
            
            七.如果根据之前存储时的位置生成的内容不等于之前存储时的划词文章内容时，表示之前的划词区域内容已被修改，则之前存储的评论也就没什么意义了，则无需展示在表格中，可以给当前 Range 添加一个标识 _rType:'diffContent';
               新生成的 Range 的 Id 应该等于原来这条数据的 ID,
               如果之前存储时的位置生成的内容不等于之前存储时的划词文章内容不一致时，则创建一个蓝色的下划线 konva.Line，透明背景的矩形 konva.Rect 且不用显示在表格中，反之显示一个红色的下划线 konva.Line 和一个暂时隐藏的黄色背景的矩形 konva.Rect 且显示在下方表格中：
               显示在表格中使用方法  setTableData(callData) :callData --- 需要回显的数据,格式为：
                    hcnr:xxx, ---> 当前选中内容
                    plnr:xxx, ---> 当前选中内容的评论
                    id:xxx, ---> 数据ID
                    sPos:xxx, ---> 当前选中内容的起始偏移量
                    ePos:xxx, ---> 当前选中内容的终止偏移量
                    _tType:xxx ---> 当前划词区域内容是否与之前划词区域内容不符

            
            八.如果文章被修改的很多，甚至之前存储的位置已经没有内容了；那么之前的划词内容也无需显示在页面上了；（根据是否能找到开始段落和结束段落来判断）


三、如何使用：
    1.JQ项目：
        主 html文件，引入项目中的 konva.min.js( konva.js 的 CDN：https://unpkg.com/konva@4.0.0/konva.min.js，不太稳定，有时候请求不到)； 
        参考 jqDemo/jqPro.html 中的 line 220 ~ line 444
    
    2.mvvm项目:
        npm install ano-underline-comments

        import { UnderlineComments,chooseRectByTool,clearAllRectOrLineByTool } from 'ano-underline-comments';

        在 mvvm项目中 如何使用请参考 mvvmIndex.vue ( demo 是 vue 项目 )，可根据你自己的项目修改 ......


四、实例上提供的方法（以下：xxx --- 创建的组件实例）
    1. xxx.delOnceRange(arg); ---> 此方法可以移除页面上的某一个Range 划词区域，参数 arg：当前需要删除的 Range 划词区域的ID
    2. xxx.rectPosList; ---> 需要传入后台待存储的数据
    3. xxx.showOldData(arg); ---> 此方法可以将之前存储的划词数据上显到页面上，参数 arg：需要显示在页面上已保存的划词数据（一般从后台获取）
